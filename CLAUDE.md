# CLAUDE.md - DACM Project Guide

## Project Overview

DACM (Desktop Agentic Coding Manager) is a Tauri 2 desktop application for managing multiple Claude Code sessions in parallel. It has a Rust backend (`core/`) and a vanilla TypeScript frontend (`view/`), with SQLite persistence via Diesel ORM.

**Current stage**: Early MVP (v0.1.0). No tests or CI/CD yet.

## Repository Structure

```
dacm/
├── core/                   # Rust backend (Tauri app)
│   ├── src/
│   │   ├── main.rs         # App entry, plugin/command registration
│   │   ├── db.rs           # Database initialization (SQLite + Diesel)
│   │   ├── models.rs       # Project data models (Queryable/Insertable)
│   │   ├── task_models.rs  # Task data models
│   │   ├── commands.rs     # Tauri commands for project management
│   │   ├── task_commands.rs# Tauri commands for task management
│   │   ├── session.rs      # Session manager (PTY lifecycle, in-memory)
│   │   ├── session_commands.rs # Tauri commands for session management
│   │   └── schema.rs       # Auto-generated Diesel schema (DO NOT EDIT)
│   ├── migrations/         # Diesel SQL migrations
│   ├── capabilities/       # Tauri security capability configs
│   ├── Cargo.toml          # Rust dependencies
│   ├── diesel.toml         # Diesel ORM config
│   └── tauri.conf.json     # Tauri app config
├── view/                   # TypeScript frontend (Vite)
│   ├── src/
│   │   ├── main.ts         # App state management & orchestration
│   │   ├── sidebar.ts      # Sidebar UI (project groups, task list)
│   │   ├── task-detail.ts  # Task detail panel & new task form
│   │   ├── types.ts        # TypeScript type definitions
│   │   └── style.css       # Dark-themed CSS with animations
│   ├── package.json        # Node dependencies & scripts
│   ├── tsconfig.json       # Strict TypeScript config
│   └── vite.config.ts      # Vite dev server (port 1420)
├── docs/                   # Product specification
├── plans/                  # Implementation plans
├── Cargo.toml              # Workspace root (members: ["core"])
└── CLAUDE.md               # This file
```

## Development Commands

### Run the app (starts both Vite dev server and Tauri window)
```bash
cargo tauri dev
```

### Build the frontend only
```bash
cd view && npm run build
```

### Check Rust compilation
```bash
cargo check
```

### Build production release
```bash
cargo tauri build
```

### Run Diesel migrations manually
```bash
cd core && diesel migration run
```

### TypeScript type checking
```bash
cd view && npx tsc --noEmit
```

## Key Architecture Patterns

### Backend (Rust)

- **State management**: All DB access through `State<DbState>` which wraps `Mutex<SqliteConnection>`
- **Session management**: PTY sessions managed via `State<SessionManager>` which wraps `Mutex<HashMap<String, SessionHandle>>`. In-memory only (not persisted to DB). Uses `portable-pty` to spawn `claude` CLI processes in pseudo-terminals.
- **Tauri commands**: Functions annotated with `#[tauri::command]` are callable from the frontend via `invoke()`
- **Error handling**: Commands return `Result<T, String>` — errors are string-based for frontend consumption
- **Migrations**: Embedded in the binary via `embed_migrations!()` and run automatically at startup
- **Schema file**: `core/src/schema.rs` is auto-generated by Diesel. Never edit it manually; run `diesel migration run` to regenerate
- **App lifecycle**: Uses `.build().run()` pattern (not `.run()`) to handle `RunEvent::ExitRequested` for killing all PTY sessions on shutdown

### Frontend (TypeScript)

- **No framework**: Vanilla TypeScript with direct DOM manipulation
- **IPC**: Uses `@tauri-apps/api` (`invoke` for commands, `listen` for events)
- **XSS protection**: All user-supplied text rendered via `escapeHtml()` helper
- **Event delegation**: Used for dynamically created elements (task lists, status buttons)
- **Module structure**: Each file exports render/update functions consumed by `main.ts`

### Database

- **Engine**: SQLite (bundled via `libsqlite3-sys`)
- **ORM**: Diesel 2 with compile-time query checking
- **Tables**: `projects` (id, name, path, created_at) and `tasks` (id, name, description, summary, task_id, project_id, status, start_time, iteration_count, worktree_path, branch_name, created_at)
- **Task statuses**: `running`, `waiting`, `completed`, `archived`

## Code Conventions

### Rust
- Edition 2021, workspace-based Cargo project
- Serde `derive` for all models crossing the IPC boundary
- Diesel `Queryable`/`Insertable` derives for DB models
- `chrono::NaiveDateTime` for timestamp fields

### TypeScript
- Strict mode with all lint flags enabled (`noUnusedLocals`, `noUnusedParameters`, `noFallthroughCasesInSwitch`)
- ES2022 target, ESNext modules
- No semicolons are not enforced — current code uses semicolons consistently
- Type definitions centralized in `types.ts`

## Important Files to Know

| File | Why it matters |
|------|---------------|
| `core/src/main.rs` | All Tauri command handlers are registered here; shutdown cleanup |
| `core/src/session.rs` | SessionManager + SessionHandle — PTY lifecycle (in-memory, no DB) |
| `core/src/session_commands.rs` | Tauri commands: spawn/write/resize/kill/list/stream sessions |
| `core/src/schema.rs` | Auto-generated — never edit manually |
| `core/tauri.conf.json` | App identity, build commands, window config |
| `core/capabilities/default.json` | Tauri security permissions |
| `view/src/types.ts` | Shared TypeScript interfaces (must match Rust models) |
| `docs/PRODUCT_SPEC.md` | Product vision and feature roadmap |

## Things to Watch Out For

- **schema.rs is auto-generated**: If you change migrations, run `diesel migration run` to update it. Do not edit by hand.
- **Frontend types must match Rust structs**: `view/src/types.ts` interfaces must stay in sync with the serde-serialized Rust models in `models.rs`, `task_models.rs`, and `session.rs` (`SessionInfo`).
- **Sessions are ephemeral**: `SessionManager` is in-memory only. PTY handles cannot be serialized. On app restart, all sessions are gone. Task status in the DB should be updated separately when sessions start/end.
- **Single DB connection**: The app uses a single `Mutex<SqliteConnection>`. All DB access is synchronous and serialized — this is intentional for SQLite.
- **No test infrastructure yet**: Tests are planned but not implemented. When adding features, keep testability in mind.
- **Tauri security capabilities**: New Tauri plugin permissions must be declared in `core/capabilities/default.json`.
